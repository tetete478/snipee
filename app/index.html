<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Snipee</title>
  <link rel="stylesheet" href="common/variables.css">
  <link rel="stylesheet" href="common/common.css">
  <script src="common/utils.js"></script>
  <script src="common/theme.js"></script>
  <style>
    /* index.html å›ºæœ‰ã®ã‚¹ã‚¿ã‚¤ãƒ«ã®ã¿ */
    .history-preview {
      padding: 6px 12px 6px 36px;
      font-size: 12px;
      color: #666;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border-top: 1px solid #f8f8f8;
    }

    .footer-btn {
      background: none;
      border: none;
      color: #666;
      font-size: 13px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: var(--border-radius);
      transition: background var(--transition-speed);
    }

    .footer-btn:hover {
      background: var(--hover-bg);
    }

    /* æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹ */
    .search-box {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-color);
      -webkit-app-region: no-drag;
    }

    .search-box input {
      width: 100%;
      padding: 6px 10px;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      font-size: var(--font-size-normal);
      font-family: var(--font-family);
      outline: none;
    }

    .search-box input:focus {
      border-color: var(--primary-color);
    }
  </style>
</head>
<body class="popup-window">
  <div class="container popup-container">
    <div class="content" id="main-content">
      <div class="section">
        <div class="section-header">å±¥æ­´</div>
        <div id="history-section"></div>
      </div>

      <div class="section">
        <div class="section-header">ã‚¹ãƒ‹ãƒšãƒƒãƒˆ</div>
        <div id="snippet-section"></div>
      </div>

      <div class="section">
        <div class="action-item" onclick="clearHistory()">
          <span class="action-icon">ğŸ—‘ï¸</span>
          <span>å±¥æ­´ã‚’ã‚¯ãƒªã‚¢</span>
        </div>
        <div class="action-item" onclick="openSnippetEditor()">
          <span class="action-icon">âœ</span>
          <span>ã‚¹ãƒ‹ãƒšãƒƒãƒˆç·¨é›†</span>
        </div>
        <div class="action-item" onclick="openSettings()">
          <span class="action-icon">âš™</span>
          <span>ç’°å¢ƒè¨­å®š</span>
        </div>
        <div class="action-item" onclick="quitApp()">
          <span class="action-icon">Ã—</span>
          <span>Snipeeã‚’çµ‚äº†</span>
        </div>
      </div>
    </div>

    <div class="footer">
      <div class="footer-row">
        <span><span class="key">â†‘â†“</span>é¸æŠ</span>
        <span><span class="key">â†’</span>å±•é–‹</span>
      </div>
      <div class="footer-row">
        <span><span class="key">â†</span>é–‰ã˜ã‚‹</span>
        <span><span class="key">Esc</span>çµ‚äº†</span>
      </div>
    </div>
  </div>

  <div class="submenu-overlay">
    <div class="submenu-container" id="inline-submenu"></div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');
    const Store = require('electron-store');
    const store = new Store();

    let allItems = {
      history: [],
      personal: [],
      master: []
    };

    let pinnedItems = [];
    let nav;
    let historyGroups = [];  // â˜… è¿½åŠ 

    async function init() {
      setupEventListeners();  // navã‚’å…ˆã«åˆæœŸåŒ–
      await loadAllItems();
    }

    async function loadAllItems(sendReady = true) {
      const data = await ipcRenderer.invoke('get-all-items');
      
      allItems.history = data.history || [];
      allItems.personal = (data.personalSnippets || []).map(s => ({ ...s, type: 'personal' }));
      allItems.master = (data.masterSnippets || []).map(s => ({ ...s, type: 'master' }));
      pinnedItems = data.pinnedItems || [];

      render();
  
      // åˆå›ã®ã¿ãƒªã‚µã‚¤ã‚ºï¼ˆsendReady=trueã®æ™‚ã®ã¿ï¼‰
      if (sendReady) {
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const bodyRect = document.body.getBoundingClientRect();
        const actualWidth = Math.ceil(bodyRect.width);
        const actualHeight = Math.ceil(bodyRect.height);
        
        await ipcRenderer.invoke('resize-window', { width: actualWidth, height: actualHeight });
        
        ipcRenderer.send('window-ready');
      }
    }

    function setupEventListeners() {
      // KeyboardNavigatoråˆæœŸåŒ–
      nav = new KeyboardNavigator({
      // â˜… data-history-group ã‚’ data-group-index ã«å¤‰æ›´
      itemSelector: '.menu-item[data-group-index], .menu-item[data-folder], .action-item',
        onFocusChange: (item) => {
          if (item && !item.classList.contains('action-item')) {
            showSubmenuForSelectedItem(false);  // è¡¨ç¤ºã®ã¿ã€ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ç§»å‹•ãªã—
          } else {
            hideInlineSubmenu();
          }
        },
        onEscape: async () => {
          hideInlineSubmenu();
          await ipcRenderer.invoke('hide-window');
        },
        onEnter: (item) => {
          if (item?.classList.contains('action-item')) {
            item.click();
          } else {
            showSubmenuForSelectedItem();
          }
        },
        onRight: () => showSubmenuForSelectedItem(true),  // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚‚ç§»å‹•
        onLeft: () => hideInlineSubmenu(),
        onSubmenuEnter: (item) => pasteSubmenuItem(item.content),
        onSubmenuMove: () => nav.updateSubmenuVisual(),
        onNumberKey: (item) => {
          if (item?.classList.contains('action-item')) {
            item.click();
          } else {
            showSubmenuForSelectedItem();
          }
        }
      });
      nav.attach();

      ipcRenderer.on('pre-load-data', async () => {
        await loadAllItems(false);
      });

      ipcRenderer.on('personal-snippets-updated', () => {
        loadAllItems(false);
      });
    }

    function render(query = '') {
      renderHistory(query);
      renderSnippets(query);
      updateSelectableItems();
    }

    function renderHistory(query = '') {
      const container = document.getElementById('history-section');
      let items = allItems.history;

      if (query) {
        const lowerQuery = query.toLowerCase();
        items = items.filter(item => 
          (item.content || '').toLowerCase().includes(lowerQuery)
        );
      }

      if (items.length === 0) {
        container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ğŸ“‹</div><div class="empty-state-text">å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</div></div>';
        return;
      }

      const groups = groupHistoryItems(items);
      
      // â˜… data-history-group ã‚’ data-group-index ã«å¤‰æ›´
      container.innerHTML = groups.map((group, index) => `
        <div class="menu-item" 
            data-group-id="history-${index}"
            data-group-index="${index}">
          <div class="menu-item-left">
            <span class="menu-item-icon">ğŸ“„</span>
            <span class="menu-item-text">${group.label}</span>
          </div>
          <span class="menu-item-arrow">â€º</span>
        </div>
      `).join('');
    }

    function updateSelectableItems() {
        // â˜… data-history-group ã‚’ data-group-index ã«å¤‰æ›´
        nav.updateItems('.menu-item[data-group-index], .menu-item[data-folder], .action-item');
        
        nav.selectableItems.forEach((item, index) => {
        item.addEventListener('mouseenter', () => {
          nav.selectedIndex = index;
          nav.updateVisual();
          // ãƒ•ã‚©ãƒ«ãƒ€/å±¥æ­´ã‚°ãƒ«ãƒ¼ãƒ—ãªã‚‰ã‚µãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡¨ç¤º
          if (!item.classList.contains('action-item')) {
            showSubmenuForSelectedItem(false);
          } else {
            hideInlineSubmenu();
          }
        });
        
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          if (item.classList.contains('action-item')) {
            // action-itemã¯æ—¢å­˜ã®onclickã§å‡¦ç†
            return;
          }
          // ãƒ•ã‚©ãƒ«ãƒ€/å±¥æ­´ã‚°ãƒ«ãƒ¼ãƒ—ã¯ã‚µãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡¨ç¤ºï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹ä»˜ãï¼‰
          showSubmenuForSelectedItem(true);
        });
      });
    }

    function groupHistoryItems(items) {
      if (items.length === 0) return [];
      
      const totalCount = items.length;
      const groups = [];
      
      const pinned = allItems.history.filter(item => pinnedItems.includes(item.id));
      if (pinned.length > 0) {
        groups.push({
          start: null,
          end: null,
          label: 'â— ãƒ”ãƒ³ç•™ã‚',
          items: pinned,
          isPinned: true
        });
      }
      
      for (let i = 0; i < Math.min(totalCount, 45); i += 15) {
        const start = i + 1;
        const end = Math.min(i + 15, totalCount);
        const groupItems = items.slice(i, i + 15);
        
        groups.push({
          start,
          end,
          label: `${start} - ${end}`,
          items: groupItems,
          isPinned: false
        });
      }
      
      // â˜… ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ä¿å­˜
      historyGroups = groups;
      
      return groups;
    }

    function renderSnippets(query = '') {
      const container = document.getElementById('snippet-section');
      let items = [...allItems.master, ...allItems.personal];

      const hiddenFolders = store.get('hiddenFolders', []);
      items = items.filter(item => !hiddenFolders.includes(item.folder || 'æœªåˆ†é¡'));

      if (query) {
        const lowerQuery = query.toLowerCase();
        items = items.filter(item => {
          const searchText = [
            item.title || '',
            item.content || '',
            item.folder || ''
          ].join(' ').toLowerCase();
          return searchText.includes(lowerQuery);
        });
      }

      if (items.length === 0) {
        container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ğŸ“</div><div class="empty-state-text">ã‚¹ãƒ‹ãƒšãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“</div></div>';
        return;
      }

      const folders = groupByFolder(items);
      
      container.innerHTML = Object.entries(folders).map(([folder, snippets]) => `
        <div class="menu-item" 
            data-group-id="folder-${folder}"
            data-folder="${folder}" 
            data-snippets='${JSON.stringify(snippets).replace(/'/g, "&apos;")}'>
          <div class="menu-item-left">
            <span class="menu-item-icon">ğŸ“</span>
            <span class="menu-item-text">${escapeHtml(folder)}</span>
          </div>
          <span class="menu-item-arrow">â€º</span>
        </div>
      `).join('');
    }

    async function openSnippetEditor() {
      await ipcRenderer.invoke('open-snippet-editor');
    }

    async function clearHistory() {
      if (confirm('ã™ã¹ã¦ã®å±¥æ­´ã‚’å‰Šé™¤ã—ã¾ã™ã‹?')) {
        await ipcRenderer.invoke('clear-all-history');
        await loadAllItems();
      }
    }

    async function openSettings() {
      await ipcRenderer.invoke('hide-window');
      await ipcRenderer.invoke('show-settings');
    }

    async function quitApp() {
      if (confirm('Snipeeã‚’çµ‚äº†ã—ã¾ã™ã‹?')) {
        await ipcRenderer.invoke('quit-app');
      }
    }

    function showSubmenuForSelectedItem(focusSubmenu = true) {
      const item = nav.getSelectedItem();
      if (!item) return;
      
      if (item.tagName === 'INPUT' || item.classList.contains('action-item')) {
        hideInlineSubmenu();
        return;
      }
      
      if (item.classList.contains('menu-item')) {
        let items = [];
        
        try {
          // â˜… data-group-index ã‚’ä½¿ã†æ–¹å¼ã«å¤‰æ›´
          if (item.hasAttribute('data-group-index')) {
            const groupIndex = parseInt(item.getAttribute('data-group-index'), 10);
            const group = historyGroups[groupIndex];
            
            if (group && group.items) {
              items = group.items.map(h => ({
                id: h.id,
                type: 'history',
                title: h.content.substring(0, 30) + (h.content.length > 30 ? '...' : ''),
                content: h.content
              }));
            }
          } else if (item.hasAttribute('data-folder')) {
            const rawData = item.getAttribute('data-snippets');
            items = JSON.parse(rawData);
          }
          
          if (items.length > 0) {
            showInlineSubmenu(item, items, focusSubmenu);
          }
        } catch (error) {
          ipcRenderer.send('log', 'ã‚¨ãƒ©ãƒ¼: ' + error.message);
        }
      }
    }
    
    async function showInlineSubmenu(targetElement, items, focusSubmenu = true) {
      const submenu = document.getElementById('inline-submenu');
      const bounds = targetElement.getBoundingClientRect();
      
      // ã¾ãšæœ€å¤§ã‚µã‚¤ã‚ºã§ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’æ‹¡å¤§
      await ipcRenderer.invoke('resize-window', { width: SUBMENU_CONFIG.maxWindowWidth, height: SUBMENU_CONFIG.maxWindowHeight });
      
      let top = SUBMENU_CONFIG.margin + SUBMENU_CONFIG.topOffset;
      
      const maxHeight = SUBMENU_CONFIG.maxWindowHeight - SUBMENU_CONFIG.margin * 2;
      submenu.style.maxHeight = maxHeight + 'px';
      submenu.style.overflowY = 'auto';
      
      submenu.style.left = (bounds.right - 5) + 'px';
      submenu.style.top = top + 'px';
      
      if (focusSubmenu) {
        nav.openSubmenu(items);
      }
      
      submenu.innerHTML = items.map((item, index) => {
        const isHistoryItem = item.id && item.type === 'history';
        const isPinned = isHistoryItem && pinnedItems.includes(item.id);
        const pinIcon = isPinned ? 'â—' : 'â—‹';
        
        const displayText = item.title || item.content || '';
        const truncatedText = displayText.length > 25 ? displayText.substring(0, 25) + '...' : displayText;
        
        return `
        <div class="submenu-item ${focusSubmenu && index === 0 ? 'selected' : ''}" data-index="${index}">
          <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
            <div class="submenu-item-title"><span class="submenu-item-icon">ğŸ“„</span> ${index + 1}. ${escapeHtml(truncatedText)}</div>
            ${isHistoryItem ? `<span class="pin-button" data-item-id="${item.id}" style="cursor: pointer; font-size: 10px; flex-shrink: 0; color: #666; -webkit-app-region: no-drag;">${pinIcon}</span>` : ''}
          </div>
        </div>
      `;
      }).join('');
      
      submenu.classList.add('visible');
  
      submenu.querySelectorAll('.submenu-item').forEach((element, index) => {
        element.addEventListener('click', async () => {
          await pasteSubmenuItem(items[index].content);
        });
      });

      submenu.querySelectorAll('.pin-button').forEach((button) => {
        button.addEventListener('click', async (e) => {
          e.stopPropagation();
          const itemId = button.getAttribute('data-item-id');
          const result = await ipcRenderer.invoke('toggle-pin-item', itemId);
          pinnedItems = result.pinnedItems;
          await loadAllItems();
        });
      });

      // ã‚µãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡¨ç¤ºå¾Œã€å®Ÿéš›ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ãƒªã‚µã‚¤ã‚º
      await new Promise(resolve => setTimeout(resolve, 50));

      const containerRect = document.querySelector('.container').getBoundingClientRect();
      const submenuRect = submenu.getBoundingClientRect();

      // å¹…: ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒŠå¹… + ã‚µãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼å¹… + ã‚·ãƒ£ãƒ‰ã‚¦ç”¨ä½™ç™½
      const actualWidth = Math.ceil(containerRect.width + submenuRect.width + 15);
      // é«˜ã•: ä¸¡æ–¹ã®é«˜ã•ã®å¤§ãã„æ–¹ï¼ˆä½™è£•ã‚’æŒãŸã›ã¦+20pxï¼‰
      const actualHeight = Math.ceil(Math.max(containerRect.height, submenuRect.height + 20));

      await ipcRenderer.invoke('resize-window', { width: actualWidth, height: actualHeight });
    }

    async function hideInlineSubmenu() {
      const submenu = document.getElementById('inline-submenu');
      submenu.classList.remove('visible');
      nav.closeSubmenu();
      
      // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // ãƒ›ãƒ¼ãƒ ç”»é¢ï¼ˆ.containerï¼‰ã®å¹…ã®ã¿ã‚’å–å¾—
      const containerRect = document.querySelector('.container').getBoundingClientRect();
      const actualWidth = Math.ceil(containerRect.width);
      const actualHeight = Math.ceil(containerRect.height);
      
      // å®Ÿéš›ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ãƒªã‚µã‚¤ã‚º
      await ipcRenderer.invoke('resize-window', { width: actualWidth, height: actualHeight });
    }

    async function pasteSubmenuItem(content) {
      const decodedContent = decodeHtmlEntities(content);
      
      hideInlineSubmenu();
      await ipcRenderer.invoke('hide-window');
      
      const result = await ipcRenderer.invoke('paste-text', decodedContent);
      
      if (!result.success && result.error !== 'permission_denied') {
        ipcRenderer.send('log', 'è‡ªå‹•ãƒšãƒ¼ã‚¹ãƒˆå¤±æ•—ã€ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼æ¸ˆã¿');
      }
    }

    window.addEventListener('focus', () => {
      loadAllItems(false);
      nav.selectedIndex = 0;
      nav.updateVisual();
    });

    init();
  </script>
</body>
</html>